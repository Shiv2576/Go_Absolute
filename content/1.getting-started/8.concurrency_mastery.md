---
title: Concurrency in Go
description: Core concepts of Concurrency
navigation:
  icon: i-lucide-code-xml
---

# Concurrency in Go


### Goroutines

Goroutines are lightweight threads managed by the Go runtime, They allow you to run concurrent task without manually handling the os threads.

```go 
package main

import (
	"fmt"
	"time"
)

func printNumbers() {
	for i := 1 ; i <= 5 ; i++ {
		fmt.Println("Number , :", i)
		time.Sleep(300 * time.Millisecond)
	}
}

func main() {
	go printNumbers()
	
	fmt.Println("Main Function running...")
	time.Sleep(2 * time.Second)
	fmt.Println("Main function Ends...")
}
```

### Channels

Channels in go are built mechanism for safe communication between Goroutines.
They allow Goroutines to send and recieve values without using explicit locks(like mutex).

```go
package main

import (
	"fmt"
)

func worker(ch chan string) {
	ch <- "Work completed"
}

func main() {
	ch := make(chan string)
	
	go worker(ch)
	
	message := <-ch // recieve message
	fmt.Println(message)
}

```

#### There are two type of Channels : 

#### Unbuffered Channels
Unbuffered channels block until both sender and receiver are ready. (Synchronous Behaviour)

```go

ch := make(chan int)

go func() {
    ch <- 10   // waits until someone receives
}()

fmt.Println(<-ch) // receives 10

```

### Buffered Channels
Buffered channels allow sending without an immediate receiver (up to buffer capacity, Asynchronous Behaviour).

```go

ch := make(chan string, 3)

ch <- "A"
ch <- "B"
ch <- "C"  // buffer is full now

for i := range ch {
	fmt.Println(i)
}
```


## Select

Go select lets you wait on multiple Channels operations. Combining goroutines and channels will select  is a powerful feature in Go.


```go 

package main

import "fmt"

func main() {
	
	c1 := make(chan String)
	c2 := make(chan String)
	
	go func() {
		time.Sleep(1 * time.Second)
		c1 <- "one"
	}()
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "Two"
	}
	
	for range 2 {
		select {
			case msg1 := <-ch1:
			   fmt.Println(msg1)
			case msg2 := <-ch2:
			   fmt.Println(msg2)
		}
	}
}

```

## Mutex & RWMutex

Mutex (Mutual Exclusion Lock) ensures only one goroutine can access a critical section of code at a time.

When to use ?

- When shared data is read and written frequently.
- When any concurrent access must be serialized.

Methods are : Lock() , Unlock()

```go 

package main

import (
	"fmt"
	"sync"
)


func main() {
	var count = 0
	var mu sync.Mutex
	var wg sync.WaitGroup
	
	for i := range 5 {
		wg.Add(1)
		go func() {
			rw.Lock()
			count ++
			rw.Unlock()
		}()
		
	}
	
	wg.Done()
	fmt.Println("Final Count:", count)
}

```

RWMutex : It is a Read-Write Mutex allows multiple concurrent readers , only one Writer (and no readers).
This gives better performance when you have:
-high read operations
-low write operations

Key Methods : RLock() , RUnlock() , Lock() , Unlock().

```go

package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var data = 0 
	var rw sync.RWMutex
	var wg sync.WaitGroup
	
	wg.Add(1)
	go func() {
		defer wg.Done()
		rw.Lock()
		data = 42
		rw.Unlock()
	}()
	
	for i := range 3 {
		defer wg.Done()
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			rw.Lock()
			fmt.Println(id , data)
			rw.Unlock()
		}(i)
	}
	
	wg.Wait()
}


```

## Atomic Operations

Atomic Operations are operations that happens in one individual steps - meaning they cannot be interrupted by any goroutine.

Why we use Atomic Operations ?
- Faster than Mutex
- Lock-Free -> No blocking
- Useful for counter, Flags or Stats that changes frequently.

```go

package main

import ( 
	"sync"
	"fmt" 
	"sync/atomic"
)

func main() {
	
	var counter int64 = 0 
	
	var wg sync.WaitGroup
	
	for i := 0 ; i < 1000 ;  i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			atomic.AddInt64(&Counter, 1)
		}()
	}
	
	wg.Wait()
	fmt.Println("Final Counter :" , counter )
}
```
