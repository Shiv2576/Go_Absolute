---
title: Concurrency in Go
description: Core concepts of Concurrency
navigation:
  icon: i-lucide-code-xml
---


### Goroutines

Goroutines are lightweight threads managed by the Go runtime, They allow you to run concurrent task without manually handling the os threads.

```go 
package main

import (
	"fmt"
	"time"
)

func printNumbers() {
	for i := 1 ; i <= 5 ; i++ {
		fmt.Println("Number , :", i)
		time.Sleep(300 * time.Millisecond)
	}
}

func main() {
	go printNumbers()
	
	fmt.Println("Main Function running...")
	time.Sleep(2 * time.Second)
	fmt.Println("Main function Ends...")
}
```

## Channels

Channels in go are built mechanism for safe communication between Goroutines.
They allow Goroutines to send and recieve values without using explicit locks(like mutex).

```go
package main

import (
	"fmt"
)

func worker(ch chan string) {
	ch <- "Work completed"
}

func main() {
	ch := make(chan string)
	
	go worker(ch)
	
	message := <-ch // recieve message
	fmt.Println(message)
}

```

### Unbuffered Channels
Unbuffered channels block until both sender and receiver are ready. (Synchronous Behaviour)

```go

ch := make(chan int)

go func() {
    ch <- 10   // waits until someone receives
}()

fmt.Println(<-ch) // receives 10

```

### Buffered Channels
Buffered channels allow sending without an immediate receiver (up to buffer capacity, Asynchronous Behaviour).

```go

ch := make(chan string, 3)

ch <- "A"
ch <- "B"
ch <- "C"  // buffer is full now

for i := range ch {
	fmt.Println(i)
}
```


## Select

Go select lets you wait on multiple Channels operations. Combining goroutines and channels will select  is a powerful feature in Go.


```go 

package main

import "fmt"

func main() {
	
	c1 := make(chan String)
	c2 := make(chan String)
	
	go func() {
		time.Sleep(1 * time.Second)
		c1 <- "one"
	}()
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "Two"
	}
	
	for range 2 {
		select {
			case msg1 := <-ch1:
			   fmt.Println(msg1)
			case msg2 := <-ch2:
			   fmt.Println(msg2)
		}
	}
}

```

## Mutex & RWMutex

Mutex (Mutual Exclusion Lock) ensures only one goroutine can access a critical section of code at a time.

When to use ?

- When shared data is read and written frequently.
- When any concurrent access must be serialized.

Methods are : Lock() , Unlock()

```go 

package main

import (
	"fmt"
	"sync"
)


func main() {
	var count = 0
	var mu sync.Mutex
	var wg sync.WaitGroup
	
	for i := range 5 {
		wg.Add(1)
		go func() {
			rw.Lock()
			count ++
			rw.Unlock()
		}()
		
	}
	
	wg.Done()
	fmt.Println("Final Count:", count)
}

```

RWMutex : It is a Read-Write Mutex allows multiple concurrent readers , only one Writer (and no readers).
This gives better performance when you have:
-high read operations
-low write operations

Key Methods : RLock() , RUnlock() , Lock() , Unlock().

```go

package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var data = 0 
	var rw sync.RWMutex
	var wg sync.WaitGroup
	
	wg.Add(1)
	go func() {
		defer wg.Done()
		rw.Lock()
		data = 42
		rw.Unlock()
	}()
	
	for i := range 3 {
		defer wg.Done()
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			rw.Lock()
			fmt.Println(id , data)
			rw.Unlock()
		}(i)
	}
	
	wg.Wait()
}


```

## Atomic Operations

Atomic Operations are operations that happens in one individual steps - meaning they cannot be interrupted by any goroutine.

Why we use Atomic Operations ?
- Faster than Mutex
- Lock-Free -> No blocking
- Useful for counter, Flags or Stats that changes frequently.

```go

package main

import ( 
	"sync"
	"fmt" 
	"sync/atomic"
)

func main() {
	
	var counter int64 = 0 
	
	var wg sync.WaitGroup
	
	for i := 0 ; i < 1000 ;  i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			atomic.AddInt64(&Counter, 1)
		}()
	}
	
	wg.Wait()
	fmt.Println("Final Counter :" , counter )
}
```

## Context

context.Context is a built-in mechanism for cancellation , timeouts and passing requests-scoped values across goroutines.

```go

func main() {
	ctx , cancel := context.WithCancel(context.Background())
	
	go worker(ctx)
	
	time.Sleep(2 * time.Second)
  cancel()  
  time.Sleep(time.Second)
  
}

func worker(ctx context.Context) {
	for {
		select {
			case <-ctx.Done():
            fmt.Println("worker stopped:", ctx.Err())
            return
        default:
            fmt.Println("working...")
            time.Sleep(500 * time.Millisecond)
        }  
		}
	}
}
```


## Worker Pools

This is a type of concurrency pattern in go. They allow you to control Concurrency, limit resource usage , and process tasks efficiently using a fixed number of goroutines.

```go

func main() {
	jobs := make(chan int, 100)
	results := make(chan int, 100)
	
	for w:= 1 ; w<=3 ; w++ {
		go worker(w, jobs, results)
	}
	
	for j := 1; j <= 5; j++ {
      jobs <- j
  }
  
  close(jobs)
  
  for r := 1; r <= 5; r++ {
    fmt.Println("Result:", <-results)
  }
}

```

## Pipelines

Piplines are most elegant concurrency patterns in Go. Once you understand them , you can build stream processors, ETL systems , log processor , real-time analytics etc . 


Basic Pipeline structure


```go

func generate(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		for _ , n := range nums {
			out <- n
		}
		close(out)
	}()
	
	return out
}


func square(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		for n := range in {
			out <- n*n
			
		}
		close(out)
	}()
	
	return out
}

func main() {
    nums := generator(1, 2, 3, 4)

    squares := square(nums)

    for result := range squares {
        fmt.Println(result)
    }
}


//Output: 
//1
//4
//9
//16

```


## Fan-in / Fan-out

Fan-in and Fan-out are core currency concepts in Go.

### Fan-in 
Merge results from multiple worker goroutine into one channel.


```go
func producer(id int) <-chan int {
	out := make(chan int)
	go func() {
		for i := range 3 {
			out <- id*10 + i
			
		}
		close(out)
	}()
	
	return out
}

func fanIn(chs ...<-chan int) <-chan int {
	out := make(chan int)
	var wg sync.WaitGroup
	wg.Add(len(chs))
	
	for _ , ch := range chs {
		go func(c <-chan int) {
			for v := range c {
				out <- v
			}
		}(ch)
	}
	
	go func() {
		wg.Wait()
		close(out)
	}
	
	return out
}


```

### Fan-out

Multiple workers (goroutines) read from the same input channel and process tasks in parallel.

```go

func worker(id int, jobs <-chan int , wg *sync.WaitGroup) {
	defer wg.Done()
	for job := range jobs {
		fmt.Printf("Worker %d processing job %d\n", id, job)
		time.Sleep(200 * time.Millisecond)
	}
}

func main() {
	jobs := make(chan int)
	var wg sync.WaitGroup
	
	for i := range 3 {
		wg.Add(1)
		go worker(i , jobs , &wg)
	}
	
	for i := range  5 {
		jobs <- i
	}
	close(jobs)
	
	wg.Wait()
}

```
