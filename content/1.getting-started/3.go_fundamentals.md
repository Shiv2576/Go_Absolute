---
title: Go Fundamentals
description: Core concepts of the Go programming language
navigation:
  icon: i-lucide-code-xml
---

Go (or Golang) is a **statically typed**, **compiled**, **concurrent**, and **garbage-collected** programming language designed by Google. It emphasizes simplicity, explicit error handling, and efficient tooling.

---

## Definitions

### Functions as First-Class Citizens  
In Go, functions can be assigned to variables, passed as arguments, returned from other functions, and stored in data structures.

### Pointers  
A pointer holds the memory address of a value. Using `&` takes an address; `*` dereferences it.

### Structs  
Structs group related fields into a single type—ideal for modeling real-world entities.

### Methods & Receivers  
A method is a function with a **receiver** (a type it’s bound to). Receivers can be values or pointers.

### Interfaces  
Interfaces define a **set of method signatures**. Any type that implements all methods **implicitly** satisfies the interface—no explicit declaration needed.

### Error Handling  
Go uses **explicit error returns** (not exceptions). Idiomatic code checks `if err != nil` early and often. `panic`/`recover` exist but are reserved for truly exceptional cases.

### Generics (Go 1.18+)  
Generics allow writing type-safe, reusable functions and types that work across multiple concrete types using **type parameters**.

---

## Unified Runnable Example

All concepts above are demonstrated in this single, executable program:

```go
package main

import (
	"errors"
	"fmt"
)

// ——— STRUCTS ———
type Person struct {
	Name string
	Age  int
}

// ——— METHODS ———
func (p Person) Greet() string {
	return "Hello, " + p.Name
}

func (p *Person) SetName(newName string) {
	p.Name = newName
}

// ——— INTERFACES ———
type Geometry interface {
	Area() float64
	Perim() float64
}

type Rectangle struct{ Width, Height float64 }

func (r Rectangle) Area() float64  { return r.Width * r.Height }
func (r Rectangle) Perim() float64 { return 2 * (r.Width + r.Height) }

// ——— GENERICS ———
type Number interface {
	int | int32 | int64 | float32 | float64
}

func Scale[T Number](x T, factor float64) T {
	return T(float64(x) * factor)
}

// ——— HELPER FUNCTIONS ———
func add(a, b int) int { return a + b }

func operate(x, y int, fn func(int, int) int) int {
	return fn(x, y)
}

func multiplier(n int) func(int) int {
	return func(x int) int { return n * x }
}

// ——— ERROR HANDLING ———
func divide(a, b float64) (float64, error) {
	if b == 0 {
		return 0, errors.New("division by zero")
	}
	return a / b, nil
}

func risky() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("Recovered from panic:", r)
		}
	}()
	panic("unexpected internal error")
}

// ——— MAIN ———
func main() {
	// Functions as first-class values
	square := func(x int) int { return x * x }
	fmt.Println("square(5):", square(5))

	fmt.Println("operate(3,4,add):", operate(3, 4, add))

	double := multiplier(2)
	fmt.Println("double(5):", double(5))

	ops := []func(int, int) int{add, func(a, b int) int { return a * b }}
	fmt.Println("ops[0](3,4):", ops[0](3, 4)) // add → 7
	fmt.Println("ops[1](3,4):", ops[1](3, 4)) // mul → 12

	// Pointers
	val := 10
	ptr := &val
	fmt.Printf("Address: %p, Value: %d\n", ptr, *ptr)
	*ptr = 20
	fmt.Println("After mutation:", val)

	// Structs & Methods
	p := Person{Name: "MRT", Age: 30}
	fmt.Println("Person:", p)
	fmt.Println("Greeting:", p.Greet())
	p.SetName("Go Engineer")
	fmt.Println("Updated:", p.Name)

	// Interfaces
	var g Geometry = Rectangle{3, 4}
	fmt.Println("Area:", g.Area(), "Perimeter:", g.Perim())

	// Error handling
	if res, err := divide(10, 2); err == nil {
		fmt.Println("10/2 =", res)
	}
	if _, err := divide(10, 0); err != nil {
		fmt.Println("Error:", err)
	}

	// Panic & recover
	risky()

	// Generics
	fmt.Println("Scale(10, 3.14):", Scale(10, 3.14))
	fmt.Println("Scale(2.5, 2.0):", Scale(2.5, 2.0))
}
