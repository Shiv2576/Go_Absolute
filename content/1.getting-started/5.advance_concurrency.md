---
title: Advance Concurrency in Go
description: Senior level concept of Concurrency in Go.
navigation:
  icon: i-lucide-code-xml
---


### Semaphores 

A Semaphore is a concurrency primitive that , Allows up to n concurrent operations and blocks additional callers until the permit is realeased.

There Two Type of Semaphores:

- Binary Semaphore -> mutex-like (1 permit)
- Counting Semaphore -> bounded concurrency (N permit)


#### Why Go needs Semaphore (Even with Goroutines)

Problem with unbounded Concurrency:

- Exhaust file descriptors

- Overwhelm DB / RPC providers

- Trigger rate limits

#### Canonical Go Semaphore : Buffered Channel

A Buffered Channel with capacity N:

- Sending into channel : acquiring a permit
- Recieving from channel : releasing a permit

```go
sem := make(chan struct{}{})
```

Why struct{}?

- Zero allocation
- Zero memory
- Expresses “signal only”


Minimal Semaphore Example :

```go 

func main() {
	sem :=  make (chan struct{} , 3)
	var wg sync.WaitGroup
	
	
	for i := 0 ; i < 10 ; i++ {
		wg.Add(1)
		
		
		go func(id int) {
			defer wg.Done()
			
			sem <- struct{}{}
			defer func() { <- sem}()
			
			fmt.Println("Working:", id)
			time.Sleep(time.Second)
			
		}(i)
	}
	
	wg.Wait()
}

```


### Context Cancellation

A Context is a signal that says : "Stop what are you doing - the result no longer matters".
it carries Cancellation signal , Deadline / Timeouts , Requests-scoped values.

without Context :
- Goroutine Leaks
- Wasted CPU
- Stuck RPCs
- DB Connections never released


How Context Cancellations Actually works ? 

```go
ctx.Done() <-chan struct{}
ctx.Error() 
```

Internally:
- Done() is a channel.
- Closing it Broadcast cancellation.


```go
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

func RPC(ctx context.Context, id int, sem chan struct{}, wg *sync.WaitGroup) {

	defer wg.Done()

	select {
	case sem <- struct{}{}:
		fmt.Println("Slot Acquired: ", id)
	case <-ctx.Done():
		fmt.Println("Cancelled before acquiring slot:", id)
		return
	}

	defer func() {
		<-sem
		fmt.Println("Realeased Slot: ", id)
	}()

	select {
	case <-time.After(2 * time.Second):
		fmt.Println("RPC finished", id)
	case <-ctx.Done():
		fmt.Println("RPC cancelled mid-Flight", id)
	}

}

func main() {
	sem := make(chan struct{}, 2) // max 2 concurrent calls
	var wg sync.WaitGroup

	for i := 0; i < 5; i++ {
		wg.Add(1)

		// Each call has only 1 second to succeed
		ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
		defer cancel()

		go RPC(ctx, i, sem, &wg)
	}

	wg.Wait()
	fmt.Println("All done")
}


```
